{"name":"Msg-rpc","tagline":"Bidirectional rpc support over simple message interface, e.g. WebSocket","body":"msg-rpc\r\n=============\r\n\r\nBidirectional Rpc(Remote procedure call) support over simple message interface, such as [WebSocket](https://developer.mozilla.org/en/docs/WebSockets \"WebSocket\").\r\n\r\nNow there are WebSocket [examples](https://github.com/rooseve/msg-rpc/tree/master/example) based on [socket.io](http://socket.io/) and [sockjs](https://github.com/sockjs). Also there is a simple nodejs local example, where sending messages is just passing variables.\r\n\r\n> [Simpe Message Vs. Rpc](https://github.com/rooseve/msg-rpc/tree/master/docs/simple_message_vs_rpc.md)\r\n\r\n###Features\r\n\r\n- Simple. Just over simple sendMessage/onMessage interface, no other dependencies.\r\n\r\n- Powerful. Not only normal Rpc, but also a special one: [Rpc Service](https://github.com/rooseve/msg-rpc#rpc-service), which make the rpc pushable, in other words, the server can also send a request to the client and expect some kind of response. \r\n\r\n\r\n###How to use?\r\n\r\nBasically, there're two preparatory things to be done, for both server or client:\r\n\r\n1. Tell how to send out a message\r\n2. Forward the messages came in to the msg-rpc\r\n\r\n*Actually there's normally a 3rd for the server, when the client disconnect, the server should do some clean up work.*\r\n\r\nHere's a websocket example between browser/nodejs, but just for illustration purposes. Reference [these examples](https://github.com/rooseve/msg-rpc/tree/master/example) for more details.\r\n\r\n#####Server (NodeJs):\r\n\r\n- Install the node module\r\n\r\n\t\tnpm install msg-rpc\t\r\n\t\r\n- Create a rpc server object, named rpcSvr, and do the preparatory work (tell how to send message, and forward the messages recevied)\r\n\r\n\t\tvar MsgRpc = require(\"msg-rpc\"), RpcSvrCls = MsgRpc.rpcServer;\r\n\r\n\t\tvar rpcSvr = new RpcSvrCls({\r\n\t\t\t//the real message sending function\r\n\t\t\tsendMessage : function(msg, socketId, cb) {\r\n\t\t\t\t\r\n\t\t\t\t//socketId should be a string, which is passed in by the message function(below)\r\n\t\r\n\t\t\t\t//send the msg\r\n\t\t\t\t//in socket.io, it'll like this:\r\n\t\t\t\t//clients[socketId].send(JSON.stringify(msg));\r\n\t\t\r\n\t\t\t\t//response\r\n\t\t\t\tcb(error, result);\r\n\t\t\t}\r\n\t\t});\r\n\t\r\n\t\t//forward the message to the rpcSvr\r\n\t\t//in socket.io, it'll like this:\r\n\t\t//clients[socket.id] = socket;\r\n\t\t//socket.on('message', function(data) {\r\n\t\r\n\t\t\t//var msg = JSON.parse(data);\r\n\t\r\n\t\t\t//pass the message to the rpcSvr, with the socketId\r\n\t\t\tif (rpcSvr.isRpcMsg(msg))\r\n\t\t\t\trpcSvr.message(msg, socket.id);\r\n\t\t//});\r\n\r\n\t\t//cleanup when disconnect\r\n\t\t//socket.on('disconnect', function() {\r\n\t\r\n\t\t\trpcSvr.clearupSocketId(socket.id);\r\n\r\n\t\t\tdelete clients[socket.id];\r\n\t\t//});\r\n\r\n- Then register some procedures to listen for rpc requests.\r\n\r\n\t\t//Register a normal procedure named procedureA\r\n\t\trpcSvr.regRpc('procedureA', function(socketId, args, callback) {\r\n\t\t\r\n\t\t\t//response to the request\r\n\t\t\tcallback(error, result);\r\n\t\t});\r\n\r\n\r\n#####Browser:\r\n\r\n- Load the lib, create a rpc client, named rpcClient, and do the preparatory work (tell how to send message, and forward the messages recevied)\r\n\r\n\t\t<script src=\"/build/rpc_client.js\"></script>\r\n\r\n\t\t//create a rpc client, tell how to send the message out\r\n\t\tvar rpcClient = new MsgRpc.Client({\r\n\t\t\r\n\t\t\t//the real message sending function\r\n\t\t\tsendMessage : function(msg) {\r\n\t\t\t\t\r\n\t\t\t\t//in socket.io, it'll like this:\r\n\t\t\t\t//socket.send(JSON.stringify(msg));\r\n\t\t\t}\r\n\t\t});\r\n\t\r\n\t\t//forward the messages received to the rpcClient\r\n\t\t//in socket.io, it'll like this:\r\n\t\t//socket.on('message', function(data) {\r\n\t\t\r\n\t\t\t//var msg = JSON.parse(data);\r\n\t\t\r\n\t\t\t//here, pass the msg to the rpcClient\r\n\t\t\tif (rpcClient.isRpcMsg(msg))\r\n\t\t\t\trpcClient.message(msg);\r\n\t\t//});\r\n\t\r\n- Then use the rpcClient to do the work.\r\n\r\n\t\trpcClient.rpc('procedureA', {\r\n\t\t\ta : 1\r\n\t\t}, function(err, result) {\r\n\t\r\n\t\t\t//here's the procedure response\r\n\t\t\tconsole.log('procedureA return ', arguments);\r\n\t\t});\r\n\r\n\r\n\r\n> **Again, there are socket.io/sockjs/node [examples](https://github.com/rooseve/msg-rpc/tree/master/example), reference them for more details.**\r\n\r\n\r\n### Advanced usage\r\n\r\n#### Rpc Service\r\n\r\nRpc itself is very like http request, client request, server response. But the simple message interface here, e.g. WebSocket, is bidirectional, server can push messages. On the client side, there must be some way to recevie these messages, and the most important, forward them to the right function to deal with.\r\n\r\nThat's why another kind of Rpc came out, named as **Rpc Service**, here's what it's like:\r\n\r\n\t//Register a service named serviceB\r\n\trpcSvr.regService('serviceB', function(socketId, args, callback, messenger) {\r\n\r\n\t\t//compared to regRpc, here we got an extra \"messenger\" parameter\r\n\t});\r\n\r\nThe key point is the 3rd parameter **messenger**.\r\n\r\n#### What's messenger?\r\n\r\nMessenger works as a pair, normally one on the client side, one on the server side. Both work the same way(share the same source code).\r\n\r\nLet's say there is such a pair, MsgerA and MsgerB. It's very like that there's a private pipeline between them, so they can communicate with each other without any other conserns. MsgerA send a message, MsgerB will get that, and vice versa.\r\n\r\nA messenger, e.g. MsgerA got 2 group of functions:\r\n\r\n##### sendMsg / onMsg\r\n\r\n- Send a message to MsgerB:\r\n\r\n\t\tMsgerA.sendMsg(msg); \r\n\r\n- Receive messages from MsgerB\r\n\r\n\t\tMsgerA.onMsg(function(msg){\r\n\t\t\t//messages from MsgerB\r\n\t\t});\r\n\t\r\n\r\n##### callCmd / onCmd (cmd is very like rpc, just to distinguish)\r\n \r\n- Call cmd which will be excuted on MsgerB\r\n \r\n\t\tMsgerA.callCmd('cmdA', args, function(err, result) {\r\n\t\t\t//here we got the response from MsgerB\r\n\t\t});\r\n\r\n\r\n- Listen for cmd requests from MsgerB\r\n\r\n\t\tMsgerA.onCmd(function(cmd, args, callbak) {\r\n\t\r\n\t\t\t//do something, and response to MsgerB\r\n\t\t\tcallbak(error, result);\r\n\t\t});\r\n\r\n\r\nWith this pair of messengers, bidirectional message/cmd(rpc) communication is supported.\r\n\r\n#### How the client got the messenger?\r\n\r\nWell, it's up to the Server, client still use the rpc method, but if the procedure is registered by \"regService\" on the server, then it's a Service procedure, and messenger will be passed in as the 3rd parameter.\r\n\r\nOn the server side, rpcSvr.regService('serviceB', function(socketId, args, callback, msgerSvr)...., then, on the client side:\r\n\r\n\trpcClient.rpc('serviceB', args, function(err, result, msgerClient) {\r\n\t\t//here you got the messenger \"msgerClient\", and with msgerSvr as a pair.\r\n\t\t//just say hello to the msgerSvr\r\n\t\tmsgerClient.sendMsg({\r\n\t\t\thi : 'hello'\r\n\t\t});\r\n\t}\r\n\r\n\r\n#### How could messengers be helpful?\r\n\r\nMessenger is just a variable with msg/cmd interface, when some client call this Rpc Service, the server and client could both keep the messenger variables, and talk to each other in the future.\r\n\t\r\nImagine that there's a group chat app, the client could rpc a service to join some group, and the server will keep every client's messenger. When some client send out a message through its messenger, the corresponding messenger on the server side will received that, and the server could just loop through all other messengers in this group and call the sendMsg function. Very easy, right?\r\n\r\n\r\n###How to build\r\n\r\nmsg-rpc use [Grunt](http://gruntjs.com/) to build the source under src folder.\r\n\r\nIn the project folder, run:\r\n\r\n\tnpm install\r\n\r\n\tgrunt\r\n\r\nIf grunt not installed yet, run:\r\n\r\n\tnpm install -g grunt-cli\r\n\t\r\n\tgrunt\r\n\r\n\r\nThe some final libraries will be generated in the build folder, e.g.\r\n\r\n- rpc_client.js, works on browser\r\n\r\n- rpc_node.js, works on Node\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}